# -*- coding: utf-8 -*-
"""optimizing agricultural technique

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tlga-_WrUJqc6uSzg5dKMWxCUl6WmdzN
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns 
import sklearn.cluster
import streamlit as st


data = pd.read_csv("E:/Downloads/optimalcrop/agricultural project dataset.csv")


data.hist(figsize=(12,12), layout=(4,4), bins=20) 

from sklearn.cluster import KMeans
#removing the label columns as for kmeans clustering meathod we don't require labels
x=data.drop(['label'],axis=1)
#selecting all the values of data
x=x.values
#checking the shape
x.shape

#Determine Optimum number of cluster by elbow method
from sklearn.cluster import KMeans
plt.rcParams['figure.figsize'] = (10,4)
wcss = [] #An empty list is created to store the Within-Cluster-Sum-of-Squares (WCSS) values for each number of clusters.
for i in range (1,11):
    km = KMeans(n_clusters =i, init= 'k-means++', max_iter=300, n_init=10, random_state=0)
    km.fit(x)
    wcss.append(km.inertia_)   #The inertia_ attribute of the KMeans object is used to calculate the WCSS value for each value of 'i', which is then appended to the list 'wcss'.
#plot the results
plt.plot(range(1,11), wcss)
plt.title('Elbow Method', fontsize= 15)
plt.xlabel('No. of cluster')
plt.ylabel('wcss')
plt.show()

#OBSERVATION
#we get two elbows at 3 and 4. As per elbow method definition we take the last one so our no. of cluster will be #4

km = KMeans(n_clusters =4, init= 'k-means++', max_iter=300, n_init=10, random_state=0)
y_means= km.fit_predict(x)
a = data['label']
y_means = pd.DataFrame(y_means)
w = pd.concat([y_means, a], axis=1)
w =w.rename(columns= {0:'cluster'})

#After performing K-means clustering on the dataset 'x' with 4 clusters and assigning each data point to its respective cluster using the
# 'fit_predict' method, the code creates a new DataFrame 'w' by concatenating the cluster assignments (stored in 'y_means') with the original 'label' column
# from the 'data' DataFrame. The 'axis=1' argument is used to concatenate the two DataFrames along the columns.

for i in range(0,4): #for 4 clusters 0,1,2,3
    print('Crops is cluster', i, w[w['cluster']==i]['label'].unique())
    print('---------------------------------------------------------------------------------------')

#splitting the dataset x contains all the crops as well as the 7factors affecting the crops and y just contains all the labels that is the crops this is done to maintain the accuracy of the model 
y=data['label']
x=data.drop(['label'],axis=1)
print("shape of x",x.shape)
print("shape of y",y.shape)

#creating training and testing set splitting the dataset in the ratio of 80 and 20 where 80 percent data goes fpr training set and 20 percent for test set 
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.2, random_state=0)
print("shape of x train",x_train.shape)
print("shape of x test",x_test.shape)
print("shape of y train",y_train.shape)
print("shape of y test",y_test.shape)

#creating a predictive model
from sklearn.linear_model import LogisticRegression
model=LogisticRegression()
model.fit(x_train,y_train) #This line trains the logistic regression model on the training data x_train and the corresponding labels y_train.
y_pred= model.predict(x_test) #This line makes predictions on the test data x_test using the trained model and assigns the predicted labels to the variable y_pred.


# Load the trained Logistic Regression model
model = LogisticRegression()
model.fit(x_train, y_train)  # Make sure x_train and y_train are defined from your previous code

# Streamlit app for crop prediction
st.title('Optimal Crop Recommendation System')
st.subheader('Adjust the values to get prediction')

# File uploader for dataset
uploaded_file = st.file_uploader("Upload CSV file", type=['csv'])

if uploaded_file is not None:
    data = pd.read_csv(uploaded_file)
else:
    st.warning('Please upload a CSV file to continue.')

# Input sliders for environmental factors
N = st.slider('Nitrogen content in soil', min_value=0, max_value=200, value=100)
P = st.slider('Phosphorus content in soil', min_value=0, max_value=150, value=50)
K = st.slider('Potassium content in soil', min_value=0, max_value=250, value=100)
temperature = st.slider('Temperature in Celsius', min_value=0, max_value=50, value=25)
humidity = st.slider('Relative humidity in %', min_value=0, max_value=100, value=50)
ph = st.slider('pH value of the soil', min_value=0.0, max_value=14.0, value=7.0)
rainfall = st.slider('Rainfall in mm', min_value=0, max_value=300, value=100)

# Predicting the crop using the Logistic Regression model
prediction = model.predict(np.array([[N, P, K, temperature, humidity, ph, rainfall]]))

st.subheader('Predicted Crop:')
st.markdown(f'<p style="font-size:30px; font-weight:bold;">{prediction[0]}</p>', unsafe_allow_html=True)

